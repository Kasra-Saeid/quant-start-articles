
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="google-site-verification" content="wl3-8ed1QZjI0iYZMv10zoZWYElkMObTfwLlWIj9cpA" />
    <meta name="description" content="Kalman Filter-Based Pairs Trading Strategy In QSTrader">

    <link rel="icon" href="/static/images/favicon.png">

    <title>Kalman Filter-Based Pairs Trading Strategy In QSTrader | QuantStart</title>
    
    
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,900&display=swap" rel="stylesheet"> 
<link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700,900&display=swap" rel="stylesheet"> 
<link href="/static/css/bootstrap.min.css" rel="stylesheet">
<link href="/static/css/prism.css" rel="stylesheet">
<link href="/static/css/qs.css?v=10" rel="stylesheet">
    
  </head>

  <body>
    <header class="header covered-header" style="background-image: linear-gradient(rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0.8)), url(https://quantstartmedia.s3.amazonaws.com/images/article-images/article-backgrounds/default-bg.jpg);">
  
<nav class="nav">
  <div class="container nav-container">
    <div class="nav-row row d-flex justify-content-between align-items-center">
      <div class="col-2">
        <ul class="nav-items justify-content-end small-capitals align-items-center">
          <li class="nav-item">
            <a class="link-fade" href="/">QuantStart</a>
          </li>
        </ul>
      </div>
      <div class="col-auto col-logo">
        <ul id="top-nav-menu" class="nav-items justify-content-end align-items-center">
          
          <li class="nav-item">
            <a class="link-fade" href="/qsalpha/">QSAlpha</a>
          </li>
          
          
          <li class="nav-item">
            <a class="link-fade" href="/quantcademy/">Quantcademy</a>
          </li>
          
          <li id="menu-link-ebooks" class="nav-item">
            <a class="link-fade" href="#">Books</a>
            <div id="menu-pane-ebooks" class="nav-items menu-dropdown-pane">
              <div class="nav-item">
                <a class="link-fade d-block ml-3 mr-3 my-3 mt-4" href="/successful-algorithmic-trading-ebook/">Successful Algorithmic Trading</a>
              </div>
              <div class="nav-item">
                <a class="link-fade d-block ml-3 mr-3 my-3 mt-4" href="/advanced-algorithmic-trading-ebook/">Advanced Algorithmic Trading</a>
              </div>
              <div class="nav-item">
                <a class="link-fade d-block ml-3 mr-3 my-3 mt-4" href="/cpp-for-quantitative-finance-ebook/">C++ For Quantitative Finance</a>
              </div>
            </div>
          </li>
          <li class="nav-item">
            <a class="link-fade" href="/qstrader/">QSTrader</a>
          </li>
          <li class="nav-item">
            <a class="link-fade" href="/articles/">Articles</a>
          </li>
          
          <li class="nav-item">
            <a class="link-fade" href="/members/login/">Login</a>
          </li>
          
        </ul>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
      </div>
    </div>
  </div>
</nav>

<nav id="mobile-nav" class="mobile-nav text-left">
  <div class="container">
    <ul class="mt-4 ml-3 mobile-nav-menu">
      <li class="nav-item">
        <a class="link-fade d-block" href="/">QuantStart</a>
      </li>

      
      <li class="nav-item">
        <a class="link-fade d-block pt-3" href="/qsalpha/">QSAlpha</a>
      </li>
      

      
      <li class="nav-item">
        <a class="link-fade d-block pt-3" href="/quantcademy/">Quantcademy</a>
      </li>
      

      <li class="nav-item">
        <a class="link-fade d-block pt-3" href="#">Books</a>
      </li>
      <li class="nav-item sub-item">
        <a class="link-fade d-block ml-3" href="/successful-algorithmic-trading-ebook/">Successful Algorithmic Trading</a>
      </li>
      <li class="nav-item sub-item">
        <a class="link-fade d-block ml-3" href="/advanced-algorithmic-trading-ebook/">Advanced Algorithmic Trading</a>
      </li>
      <li class="nav-item sub-item">
        <a class="link-fade d-block ml-3" href="/cpp-for-quantitative-finance-ebook/">C++ For Quantitative Finance</a>
      </li>

      <li class="nav-item">
        <a class="link-fade d-block pt-3" href="/qstrader/">QSTrader</a>
      </li>

      <li class="nav-item">
        <a class="link-fade d-block pt-3" href="/articles/">Articles</a>
      </li>

      
      <li class="nav-item">
        <a class="link-fade d-block pt-3" href="/members/login/">Login</a>
      </li>
      
    </ul>
    <button class="nav-toggle mobile-nav-close">
      <svg id="mobile-nav-close-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M19.77,5.63,13.41,12l6.36,6.37a1,1,0,0,1-1.41,1.41L12,13.41,5.63,19.77a1,1,0,0,1-1.44-1.39l0,0L10.58,12,4.21,5.63a1,1,0,0,1,0-1.42,1,1,0,0,1,1.41,0l0,0L12,10.58l6.37-6.37a1,1,0,0,1,1.41,0A1,1,0,0,1,19.77,5.63Z"></path>
      </svg>
    </button>
  </div>
</nav>

  <div class="container hero-container">
    <section class="mt-5 mb-4">
      <div class="row justify-content-center">
        <div class="col-12 text-center">
          <p class="hero">Kalman Filter-Based Pairs Trading Strategy In QSTrader</p>
          <p class="hero subhero">Kalman Filter-Based Pairs Trading Strategy In QSTrader</p>
        </div>
      </div>
    </section>
  </div>
</header>
    
<section class="container content-container">
  <div class="row">
    <div class="col-md-8 order-md-2">
      <section class="content article-content">
        
        
        <p>Previously on QuantStart we have considered the mathematical underpinnings of <a href="https://www.quantstart.com/articles/State-Space-Models-and-the-Kalman-Filter">State Space Models and Kalman Filters</a>, as well as the application of the <a href="https://pykalman.github.io/">pykalman</a> library to a <a href="https://www.quantstart.com/articles/Dynamic-Hedge-Ratio-Between-ETF-Pairs-Using-the-Kalman-Filter">pair of ETFs to dynamically adjust a hedge ratio</a> as a basis for a mean reverting trading strategy.</p>

<p>In this article we will discuss a trading strategy originally due to Ernest Chan (2012)<sup><a href="#ref-chan2013">[1]</a></sup> and tested by Aidan O'Mahony over at Quantopian<sup><a href="#ref-omahony2014">[2]</a></sup>. We will make use of the Python-based <a href="https://github.com/mhallsmoore/qstrader">open-source QSTrader backtesting framework</a> in order to implement the strategy. QSTrader will carry out the "heavy lifting" of the position tracking, portfolio handling and data ingestion, while we concentrate solely on the code that generates the trading signals.</p>

<h2>The Trading Strategy</h2>

<p>The pairs-trading strategy is applied to a couple of Exchange Traded Funds (ETF) that both track the performance of varying duration US Treasury bonds. They are:</p>

<ul>
  <li><strong><a href="https://www.ishares.com/us/products/239454/ishares-20-year-treasury-bond-etf">TLT</a></strong> - iShares 20+ Year Treasury Bond ETF</li>
  <li><strong><a href="https://www.ishares.com/us/products/239455/ishares-37-year-treasury-bond-etf">IEI</a></strong> - iShares 3-7 Year Treasury Bond ETF</li>
</ul>

<p>The goal is to build a mean-reverting strategy from this pair of ETFs.</p>

<p>The synthetic "spread" between TLT and IEI is the time series that we are actually interested in longing or shorting. The Kalman Filter is used to dynamically track the hedging ratio between the two in order to keep the spread stationary (and hence mean reverting).</p>

<p>To create the trading rules it is necessary to determine when the spread has moved too far from its expected value. How do we determine what "too far" is? We could utilise a set of fixed absolute values, but these would have to be empirically determined. This would introduce another free parameter into the system that would require optimisation (and additional danger of overfitting).</p>

<p>One "parameterless" approach to creating these values is to consider a multiple of the standard deviation of the spread and use these as the bounds. For simplicity we can set the coefficient of the multiple to be equal to one.</p>

<p>Hence we can go "long the spread" if the forecast error drops below the negative standard deviation of the spread. Respectively we can go "short the spread" if the forecast error exceeds the positive standard deviation of the spread. The exit rules are simply the opposite of the entry rules.</p>

<p>The dynamic hedge ratio is represented by one component of the hidden state vector at time $t$, $\theta_t$, which we will denote as $\theta^0_t$. This is the "beta" slope value that is well known from linear regression.</p>

<p>"Longing the spread" here means purchasing (longing) $N$ units of TLT and selling (shorting) $\lfloor{ \theta^0_t N \rfloor}$, where $\lfloor{ x \rfloor}$ is the "floor" representing the highest integer less than $x$. The latter is necessary as we must transact a whole number of units of the ETFs. "Shorting the spread" is the opposite of this. $N$ controls the overall size of the position.</p>

<p>$e_t$ represents the <em>forecast error</em> or <em>residual error</em> of the prediction at time $t$, while $Q_t$ represents the variance of this prediction at time $t$.</p>

<p>For completeness, the rules are specified here:</p>

<ol>
  <li>$e_t \lt -\sqrt{Q_t}$ - Long the spread: Go long $N$ shares of TLT and go short $\lfloor{ \theta^0_t N \rfloor}$ units of IEI</li>
  <li>$e_t \ge -\sqrt{Q_t}$ - Exit long: Close all long positions of TLT and IEI</li>
  <li>$e_t \gt \sqrt{Q_t}$ - Short the spread: Go short $N$ shares of TLT and go long $\lfloor{ \theta^0_t N \rfloor}$ units of IEI</li>
  <li>$e_t \le \sqrt{Q_t}$ - Exit short: Close all short positions of TLT and IEI</li>
</ol>

<p>The role of the Kalman filter is to help us calculate $\theta_t$, as well $e_t$ and $Q_t$. $\theta_t$ represents the vector of the intercept and slope values in the linear regression between TLT and IEI at time $t$. It is estimated by the Kalman filter. The forecast error/residual $e_t = y_t - \hat{y}_t$ is the difference between the predicted value of TLT <em>today</em> and the Kalman filter's estimate of TLT <em>today</em>. $Q_t$ is the variance of the predictions and hence $\sqrt{Q_t}$ is the standard deviation of the prediction.</p>

<p><em>For more detail on where these quantities arise please see the <a href="https://www.quantstart.com/articles/State-Space-Models-and-the-Kalman-Filter">article on State Space Models and the Kalman Filter</a>.</em></p>

<p>The implementation of the strategy involves the following steps:</p>

<ol>
  <li>Receive daily market OHLCV bars for both TLT and IEI</li>
  <li>Use the recursive "online" Kalman filter to estimate the price of TLT <em>today</em> based on <em>yesterdays</em> observations of IEI</li>
  <li>Take the difference between the Kalman estimate of TLT and the actual value, often called the <em>forecast error</em> or <em>residual error</em>, which is a measure of how much the spread of TLT and IEI moves away from its expected value</li>
  <li>Long the spread when the movement is negatively far from the expected value and correspondingly short the spread when the movement is positively far from the expected value</li>
  <li>Exit the long and short positions when the series reverts to its expected value</li>
</ol>

<h3>Data</h3>

<p>In order to carry out this strategy it is necessary to have OHLCV pricing data for the period covered by this backtest. In particular it is necessary to download the following:</p>

<ul>
  <li><strong>TLT</strong> - For the period 3rd August 2009 to 1st August 2016 (link <a href="http://real-chart.finance.yahoo.com/table.csv?s=TLT&a=07&b=1&c=2009&d=07&e=1&f=2016&g=d&ignore=.csv">here</a>)</li>
  <li><strong>IEI</strong> For the period 3rd August 2009 to 1st August 2016 (link <a href="http://real-chart.finance.yahoo.com/table.csv?s=IEI&a=07&b=1&c=2009&d=07&e=1&f=2016&g=d&ignore=.csv">here</a>).</li>
</ul>

<p>This data will need to placed in the directory specified by the QSTrader settings file if you wish to replicate the results.</p>

<h2>Python QSTrader Implementation</h2>

<p>Since QSTrader handles the position tracking, portfolio management, data ingestion and order management the only code we need to write involves the <code>Strategy</code> object itself.</p>

<p>The <code>Strategy</code> communicates with the <code>PortfolioHandler</code> via the event queue, making use of <code>SignalEvent</code> objects to do so. In addition we must import the base abstract strategy class, <code>AbstractStrategy</code>.</p>

<p><em>Note that in the current alpha version of QSTrader we must also import the <code>PriceParser</code> class. This is used to multiply all prices on input by a large multiple ($10^8$) and perform integer arithmetic when tracking positions. This avoids <a href="https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html">floating point rounding issues</a> that can accumulate over the long period of a backtest. We must divide all the prices by <code>PriceParser.PRICE_MULTIPLIER</code> to obtain the correct values:</em></p>

<pre>
<code class="language-python">from math import floor

import numpy as np

from qstrader.price_parser import PriceParser
from qstrader.event import (SignalEvent, EventType)
from qstrader.strategy.base import AbstractStrategy</code>
</pre>

<p>The next step is to create the <code>KalmanPairsTradingStrategy</code> class. The job of this class is to determine when to create <code>SignalEvent</code> objects based on received <code>BarEvent</code>s from the daily OHLCV bars of TLT and IEI from Yahoo Finance.</p>

<p>There are many different ways to organise this class. I've opted to hardcode all of the parameters in the class for clarity of the explanation. Notably I've fixed the value of $\delta=10^{-4}$ and $v_t=10^{-3}$. They represent the system noise and measurement noise variance in the Kalman Filter model. This could also be implemented as a keyword argument in the <code>__init__</code> constructor of the class. Such an approach would allow straightforward parameter optimisation.</p>

<p>The first task is to set the <code>time</code> and <code>invested</code> members to be equal to <code>None</code>, as they will be updated as market data is accepted and trade signals generated. <code>latest_prices</code> is a two-array of the current prices of TLT and IEI, used for convenience through the class.</p>

<p>The next set of parameters all relate to the Kalman Filter and are explained in depth in the previous two articles <a href="https://www.quantstart.com/articles/State-Space-Models-and-the-Kalman-Filter">here</a> and <a href="https://www.quantstart.com/articles/Dynamic-Hedge-Ratio-Between-ETF-Pairs-Using-the-Kalman-Filter">here</a>.</p>

<p>The final set of parameters include <code>days</code>, used to track how many days have passed as well as <code>qty</code> and <code>cur_hedge_qty</code>, used to track the absolute quantities of ETFs to purchase for both the long and short side. I have set this to be 2,000 units on an account equity of 100,000 USD.</p>

<pre>
<code class="language-python">class KalmanPairsTradingStrategy(AbstractStrategy):
    """
    Requires:
    tickers - The list of ticker symbols
    events_queue - A handle to the system events queue
    short_window - Lookback period for short moving average
    long_window - Lookback period for long moving average
    """
    def __init__(
        self, tickers, events_queue
    ):
        self.tickers = tickers
        self.events_queue = events_queue
        self.time = None
        self.latest_prices = np.array([-1.0, -1.0])
        self.invested = None

        self.delta = 1e-4
        self.wt = self.delta / (1 - self.delta) * np.eye(2)
        self.vt = 1e-3
        self.theta = np.zeros(2)
        self.P = np.zeros((2, 2))
        self.R = None

        self.days = 0
        self.qty = 2000
        self.cur_hedge_qty = self.qty</code>
</pre>

<p>The next method <code>_set_correct_time_and_price</code> is a "helper" method utilised to ensure that the Kalman Filter has all of the correct pricing information available at the right point. This is necessary because in an event-driven backtest system such as QSTrader market information arrives sequentially.</p>

<p>We might be in a situation on day $K$ where we've received a price for IEI, but not TFT. Hence we must wait until <em>both</em> TFT and IEI market events have arrived from the backtest loop, through the events queue. In live trading this is not an issue since they will arrive almost instantaneously compared to the trading period of a few days. However, in an event-driven backtest we must wait for both prices to arrive before calculating the new Kalman filter update.</p>

<p>The code essentially checks if the subsequent event is for the current day. If it is, then the correct price is added to the <code>latest_price</code> list of TLT and IEI. If it is a new day then the latest prices are reset and the correct prices are once again added.</p>

<p><em>This type of "housekeeping" method will likely be absorbed into the QSTrader codebase in the future, reducing the necessity to write "boilerplate" code, but for now it must form part of the strategy itself.</em></p>

<pre>
<code class="language-python">def _set_correct_time_and_price(self, event):
    """
    Sets the correct price and event time for prices
    that arrive out of order in the events queue.
    """
    # Set the first instance of time
    if self.time is None:
        self.time = event.time

    # Set the correct latest prices depending upon
    # order of arrival of market bar event
    price = event.adj_close_price/PriceParser.PRICE_MULTIPLIER
    if event.time == self.time:
        if event.ticker == self.tickers[0]:
            self.latest_prices[0] = price
        else:
            self.latest_prices[1] = price
    else:
        self.time = event.time
        self.days += 1
        self.latest_prices = np.array([-1.0, -1.0])
        if event.ticker == self.tickers[0]:
            self.latest_prices[0] = price
        else:
            self.latest_prices[1] = price</code>
</pre>

<p>The core of the strategy is carried out in the <code>calculate_signals</code> method. Firstly we set the correct times and prices (as described above). Then we check that we have <em>both</em> prices for TLT and IEI, at which point we can consider new trading signals.</p>

<p>$y$ is set equal to the latest price for IEI, while $F$ is the observation matrix containing the latest price for TLT, as well as a unity placeholder to represent the intercept in the linear regression. The Kalman Filter is subsequently updated with these latest prices. Finally we calculate the forecast error $e_t$ and the standard deviation of the predictions, $\sqrt{Q_t}$. Let's run through this code step-by-step, as it looks a little complicated.</p>

<p>The first task is to form the scalar value <code>y</code> and the observation matrix <code>F</code>, containing the prices of IEI and and TLT respectively. We calculate the variance-covariance matrix <code>R</code> or set it to the zero-matrix if it has not yet been initialised. Subsequently we calculate the new prediction of the observation <code>yhat</code> as well as the forecast error <code>et</code>.</p>

<p>We then calculate the variance of the observation predictions <code>Qt</code> as well as the standard deviation <code>sqrt_Qt</code>. We use the update rules derived <a href="https://www.quantstart.com/articles/State-Space-Models-and-the-Kalman-Filter">here</a> to obtain the posterior distribution of the states <code>theta</code>, which contains the hedge ratio/slope between the two prices:</p>

<pre>
<code class="language-python">def calculate_signals(self, event):
    """
    Calculate the Kalman Filter strategy.
    """
    if event.type == EventType.BAR:
        self._set_correct_time_and_price(event)

        # Only trade if we have both observations
        if all(self.latest_prices > -1.0):
            # Create the observation matrix of the latest prices
            # of TLT and the intercept value (1.0) as well as the
            # scalar value of the latest price from IEI
            F = np.asarray([self.latest_prices[0], 1.0]).reshape((1, 2))
            y = self.latest_prices[1]

            # The prior value of the states \theta_t is
            # distributed as a multivariate Gaussian with
            # mean a_t and variance-covariance R_t
            if self.R is not None:
                self.R = self.C + self.wt
            else:
                self.R = np.zeros((2, 2))

            # Calculate the Kalman Filter update
            # ----------------------------------
            # Calculate prediction of new observation
            # as well as forecast error of that prediction
            yhat = F.dot(self.theta)
            et = y - yhat

            # Q_t is the variance of the prediction of
            # observations and hence \sqrt{Q_t} is the
            # standard deviation of the predictions
            Qt = F.dot(self.R).dot(F.T) + self.vt
            sqrt_Qt = np.sqrt(Qt)

            # The posterior value of the states \theta_t is
            # distributed as a multivariate Gaussian with mean
            # m_t and variance-covariance C_t
            At = self.R.dot(F.T) / Qt
            self.theta = self.theta + At.flatten() * et
            self.C = self.R - At * F.dot(self.R)</code>
</pre>

<p>Finally we generate the trading signals based on the values of $e_t$ and $\sqrt{Q_t}$. To do this we need to check what the "invested" status is - either "long", "short" or "None". Notice how we need to adjust the <code>cur_hedge_qty</code> current hedge quantity when we go long or short as the slope $\theta^0_t$ is constantly adjusting in time:</p>

<pre>
<code class="language-python"># Only trade if days is greater than a "burn in" period
if self.days > 1:
    # If we're not in the market...
    if self.invested is None:
        if e < -sqrt_Q:
            # Long Entry
            print("LONG: %s" % event.time)
            self.cur_hedge_qty = int(floor(self.qty*self.theta[0]))
            self.events_queue.put(SignalEvent(self.tickers[1], "BOT", self.qty))
            self.events_queue.put(SignalEvent(self.tickers[0], "SLD", self.cur_hedge_qty))
            self.invested = "long"
        elif e > sqrt_Q:
            # Short Entry
            print("SHORT: %s" % event.time)
            self.cur_hedge_qty = int(floor(self.qty*self.theta[0]))
            self.events_queue.put(SignalEvent(self.tickers[1], "SLD", self.qty))
            self.events_queue.put(SignalEvent(self.tickers[0], "BOT", self.cur_hedge_qty))
            self.invested = "short"
    # If we are in the market...
    if self.invested is not None:
        if self.invested == "long" and e > -sqrt_Q:
            print("CLOSING LONG: %s" % event.time)
            self.events_queue.put(SignalEvent(self.tickers[1], "SLD", self.qty))
            self.events_queue.put(SignalEvent(self.tickers[0], "BOT", self.cur_hedge_qty))
            self.invested = None
        elif self.invested == "short" and e < sqrt_Q:
            print("CLOSING SHORT: %s" % event.time)
            self.events_queue.put(SignalEvent(self.tickers[1], "BOT", self.qty))
            self.events_queue.put(SignalEvent(self.tickers[0], "SLD", self.cur_hedge_qty))
            self.invested = None</code>
</pre>

<p>This is all of the code necessary for the <code>Strategy</code> object. We also need to create a backtest file to encapsulate all of our trading logic and class choices. The particular version is very similar to those used in the <code>examples</code> directory and replaces the equity of 500,000 USD with 100,000 USD.</p>

<p>It also changes the <code>FixedPositionSizer</code> to the <code>NaivePositionSizer</code>. The latter is used to "naively" accept the suggestions of absolute quantities of ETF units to trade as determined in the <code>KalmanPairsTradingStrategy</code> class. In a production environment it would be necessary to adjust this depending upon the risk management goals of the portfolio.</p>

<p>Here is the full code for the <code>kalman_qstrader_backtest.py</code>:</p>

<pre>
<code class="language-python">import click

from qstrader import settings
from qstrader.compat import queue
from qstrader.price_parser import PriceParser
from qstrader.price_handler.yahoo_daily_csv_bar import YahooDailyCsvBarPriceHandler
from qstrader.strategy import Strategies, DisplayStrategy
from qstrader.position_sizer.naive import NaivePositionSizer
from qstrader.risk_manager.example import ExampleRiskManager
from qstrader.portfolio_handler import PortfolioHandler
from qstrader.compliance.example import ExampleCompliance
from qstrader.execution_handler.ib_simulated import IBSimulatedExecutionHandler
from qstrader.statistics.tearsheet import TearsheetStatistics
from qstrader.trading_session.backtest import Backtest

from kalman_qstrader_strategy import KalmanPairsTradingStrategy


def run(config, testing, tickers, filename):

    # Set up variables needed for backtest
    events_queue = queue.Queue()
    csv_dir = config.CSV_DATA_DIR
    initial_equity = PriceParser.parse(100000.00)

    # Use Yahoo Daily Price Handler
    price_handler = YahooDailyCsvBarPriceHandler(
        csv_dir, events_queue, tickers
    )

    # Use the KalmanPairsTrading Strategy
    strategy = KalmanPairsTradingStrategy(tickers, events_queue)
    strategy = Strategies(strategy, DisplayStrategy())

    # Use the Naive Position Sizer (suggested quantities are followed)
    position_sizer = NaivePositionSizer()

    # Use an example Risk Manager
    risk_manager = ExampleRiskManager()

    # Use the default Portfolio Handler
    portfolio_handler = PortfolioHandler(
        initial_equity, events_queue, price_handler,
        position_sizer, risk_manager
    )

    # Use the ExampleCompliance component
    compliance = ExampleCompliance(config)

    # Use a simulated IB Execution Handler
    execution_handler = IBSimulatedExecutionHandler(
        events_queue, price_handler, compliance
    )

    # Use the default Statistics
    statistics = TearsheetStatistics(
        config, portfolio_handler, title=""
    )

    # Set up the backtest
    backtest = Backtest(
        price_handler, strategy,
        portfolio_handler, execution_handler,
        position_sizer, risk_manager,
        statistics, initial_equity
    )
    results = backtest.simulate_trading(testing=testing)
    statistics.save(filename)
    return results


@click.command()
@click.option('--config', default=settings.DEFAULT_CONFIG_FILENAME, help='Config filename')
@click.option('--testing/--no-testing', default=False, help='Enable testing mode')
@click.option('--tickers', default='SP500TR', help='Tickers (use comma)')
@click.option('--filename', default='', help='Pickle (.pkl) statistics filename')
def main(config, testing, tickers, filename):
    tickers = tickers.split(",")
    config = settings.from_file(config, testing)
    run(config, testing, tickers, filename)


if __name__ == "__main__":
    main()</code>
</pre>

<p>As long as QSTrader is correctly installed and the data has been downloaded from Yahoo Finance the code can be executed via the following command in the terminal:</p>

<pre>
<code class="language-bash">$ python kalman_qstrader_backtest.py --tickers=TLT,IEI</code>
</pre>

<p>Thanks to the efforts of many volunteer developers, particularly <a href="https://github.com/ryankennedyio">@ryankennedyio</a> and <a href="https://github.com/femtotrader">@femtotrader</a>, the code is well-optimised for OHLCV bar data and carries out the backtesting rapidly.</p>

<h2>Strategy Results</h2>

<p>One of the latest features to be added to QSTrader is that of the "tearsheet" developed primarily by <a href="https://github.com/nwillemse">@nwillemse</a>. <em>This feature is still in an early stage of development but will be demonstrated here.</em></p>

<p>A tearsheet is primarily used within institutional settings as a "one pager" description of a trading strategy. The <code>TearsheetStatistics</code> class in the QSTrader codebase replicates many of the statistics found in a typical strategy performance report.</p>

<p>The top two graphs represent the equity curve and drawdown percentage, respectively. Beneath this are the monthly and yearly performance panels. Finally the equity curve, trade-level and time-based statistics are presented:</p>

<p style="text-align:center;">
<a href="https://s3.amazonaws.com/quantstartmedia/images/qs-qstrader-kalman-tlt-iei-tearsheet.png"><img src="https://s3.amazonaws.com/quantstartmedia/images/qs-qstrader-kalman-tlt-iei-tearsheet.png" width="100%"></a>
</p>

<p><em>Click the image for a larger view.</em></p>

<p>The equity curve begins relatively flat for the first year of the strategy but rapidly escalates during 2011. During 2012 the strategy becomes significantly more volatile remaining "underwater" until 2015 and reaching a maximum daily drawdown percentage of 15.79%. The performance gradually increases from the maximum drawdown in late 2013 through to 2016.</p>

<p>The strategy has a CAGR of 8.73% with a Sharpe Ratio of 0.75. It also has a long maximum drawdown duration of 777 days - over two years! Note that this strategy is carried out <em>gross</em> of transaction costs so the true performance would likely be worse.</p>

<h2>Next Steps</h2>

<p>There is a lot of research work necessary to turn this into a profitable strategy that we would deploy in a live setting. Potential avenues of research include:</p>

<ul>
  <li><strong>Parameter Optimisation</strong> - Varying the parameters of the Kalman Filter via cross-validation grid search or some form of machine learning optimisation. However, this introduces the distinct possibility of overfitting to historical data.</li>
  <li><strong>Asset Selection</strong> - Choosing additional, or alternative, pairs of ETFs would help to add diversification to the portfolio, but increases the complexity of the strategy as well as the number of trades (and thus transaction costs).</li>
</ul>

<p>In future articles we will consider how to carry out these procedures for various trading strategies.</p>

<h2>References</h2>

<ul>
  <li><a name="ref-chan2013" href="http://amzn.to/1Olr09O">[1] Chan, E. P. (2013) <em>Algorithmic Trading: Winning Strategies and their Rationale</em>, Wiley</a></li>
  <li><a name="ref-omahony2014" href="https://www.quantopian.com/posts/ernie-chans-ewa-slash-ewc-pair-trade-with-kalman-filter">[2] O'Mahony, A. (2014) <em>Ernie Chan's EWA/EWC pair trade with Kalman filter</em>, https://www.quantopian.com/posts/ernie-chans-ewa-slash-ewc-pair-trade-with-kalman-filter</a></li>
</ul>

<h2>Full Code</h2>

<pre>
<code class="language-python"># kalman_qstrader_strategy.py

from math import floor

import numpy as np

from qstrader.price_parser import PriceParser
from qstrader.event import (SignalEvent, EventType)
from qstrader.strategy.base import AbstractStrategy


class KalmanPairsTradingStrategy(AbstractStrategy):
    """
    Requires:
    tickers - The list of ticker symbols
    events_queue - A handle to the system events queue
    short_window - Lookback period for short moving average
    long_window - Lookback period for long moving average
    """
    def __init__(
        self, tickers, events_queue
    ):
        self.tickers = tickers
        self.events_queue = events_queue
        self.time = None
        self.latest_prices = np.array([-1.0, -1.0])
        self.invested = None

        self.delta = 1e-4
        self.wt = self.delta / (1 - self.delta) * np.eye(2)
        self.vt = 1e-3
        self.theta = np.zeros(2)
        self.P = np.zeros((2, 2))
        self.R = None

        self.days = 0
        self.qty = 2000
        self.cur_hedge_qty = self.qty

    def _set_correct_time_and_price(self, event):
        """
        Sets the correct price and event time for prices
        that arrive out of order in the events queue.
        """
        # Set the first instance of time
        if self.time is None:
            self.time = event.time

        # Set the correct latest prices depending upon
        # order of arrival of market bar event
        price = event.adj_close_price/PriceParser.PRICE_MULTIPLIER
        if event.time == self.time:
            if event.ticker == self.tickers[0]:
                self.latest_prices[0] = price
            else:
                self.latest_prices[1] = price
        else:
            self.time = event.time
            self.days += 1
            self.latest_prices = np.array([-1.0, -1.0])
            if event.ticker == self.tickers[0]:
                self.latest_prices[0] = price
            else:
                self.latest_prices[1] = price

    def calculate_signals(self, event):
        """
        Calculate the Kalman Filter strategy.
        """
        if event.type == EventType.BAR:
            self._set_correct_time_and_price(event)

            # Only trade if we have both observations
            if all(self.latest_prices > -1.0):
                # Create the observation matrix of the latest prices
                # of TLT and the intercept value (1.0) as well as the
                # scalar value of the latest price from IEI
                F = np.asarray([self.latest_prices[0], 1.0]).reshape((1, 2))
                y = self.latest_prices[1]

                # The prior value of the states \theta_t is
                # distributed as a multivariate Gaussian with
                # mean a_t and variance-covariance R_t
                if self.R is not None:
                    self.R = self.C + self.wt
                else:
                    self.R = np.zeros((2, 2))

                # Calculate the Kalman Filter update
                # ----------------------------------
                # Calculate prediction of new observation
                # as well as forecast error of that prediction
                yhat = F.dot(self.theta)
                et = y - yhat

                # Q_t is the variance of the prediction of
                # observations and hence \sqrt{Q_t} is the
                # standard deviation of the predictions
                Qt = F.dot(self.R).dot(F.T) + self.vt
                sqrt_Qt = np.sqrt(Qt)

                # The posterior value of the states \theta_t is
                # distributed as a multivariate Gaussian with mean
                # m_t and variance-covariance C_t
                At = self.R.dot(F.T) / Qt
                self.theta = self.theta + At.flatten() * et
                self.C = self.R - At * F.dot(self.R)

                # Only trade if days is greater than a "burn in" period
                if self.days > 1:
                    # If we're not in the market...
                    if self.invested is None:
                        if et < -sqrt_Qt:
                            # Long Entry
                            print("LONG: %s" % event.time)
                            self.cur_hedge_qty = int(floor(self.qty*self.theta[0]))
                            self.events_queue.put(SignalEvent(self.tickers[1], "BOT", self.qty))
                            self.events_queue.put(SignalEvent(self.tickers[0], "SLD", self.cur_hedge_qty))
                            self.invested = "long"
                        elif et > sqrt_Qt:
                            # Short Entry
                            print("SHORT: %s" % event.time)
                            self.cur_hedge_qty = int(floor(self.qty*self.theta[0]))
                            self.events_queue.put(SignalEvent(self.tickers[1], "SLD", self.qty))
                            self.events_queue.put(SignalEvent(self.tickers[0], "BOT", self.cur_hedge_qty))
                            self.invested = "short"
                    # If we are in the market...
                    if self.invested is not None:
                        if self.invested == "long" and et > -sqrt_Qt:
                            print("CLOSING LONG: %s" % event.time)
                            self.events_queue.put(SignalEvent(self.tickers[1], "SLD", self.qty))
                            self.events_queue.put(SignalEvent(self.tickers[0], "BOT", self.cur_hedge_qty))
                            self.invested = None
                        elif self.invested == "short" and et < sqrt_Qt:
                            print("CLOSING SHORT: %s" % event.time)
                            self.events_queue.put(SignalEvent(self.tickers[1], "BOT", self.qty))
                            self.events_queue.put(SignalEvent(self.tickers[0], "SLD", self.cur_hedge_qty))
                            self.invested = None</code>
</pre>

<pre>
<code class="language-python"># kalman_qstrader_backtest.py

import click

from qstrader import settings
from qstrader.compat import queue
from qstrader.price_parser import PriceParser
from qstrader.price_handler.yahoo_daily_csv_bar import YahooDailyCsvBarPriceHandler
from qstrader.strategy import Strategies, DisplayStrategy
from qstrader.position_sizer.naive import NaivePositionSizer
from qstrader.risk_manager.example import ExampleRiskManager
from qstrader.portfolio_handler import PortfolioHandler
from qstrader.compliance.example import ExampleCompliance
from qstrader.execution_handler.ib_simulated import IBSimulatedExecutionHandler
from qstrader.statistics.tearsheet import TearsheetStatistics
from qstrader.trading_session.backtest import Backtest

from kalman_qstrader_strategy import KalmanPairsTradingStrategy


def run(config, testing, tickers, filename):

    # Set up variables needed for backtest
    events_queue = queue.Queue()
    csv_dir = config.CSV_DATA_DIR
    initial_equity = PriceParser.parse(100000.00)

    # Use Yahoo Daily Price Handler
    price_handler = YahooDailyCsvBarPriceHandler(
        csv_dir, events_queue, tickers
    )

    # Use the KalmanPairsTrading Strategy
    strategy = KalmanPairsTradingStrategy(tickers, events_queue)
    strategy = Strategies(strategy, DisplayStrategy())

    # Use the Naive Position Sizer (suggested quantities are followed)
    position_sizer = NaivePositionSizer()

    # Use an example Risk Manager
    risk_manager = ExampleRiskManager()

    # Use the default Portfolio Handler
    portfolio_handler = PortfolioHandler(
        initial_equity, events_queue, price_handler,
        position_sizer, risk_manager
    )

    # Use the ExampleCompliance component
    compliance = ExampleCompliance(config)

    # Use a simulated IB Execution Handler
    execution_handler = IBSimulatedExecutionHandler(
        events_queue, price_handler, compliance
    )

    # Use the default Statistics
    statistics = TearsheetStatistics(
        config, portfolio_handler, title=""
    )

    # Set up the backtest
    backtest = Backtest(
        price_handler, strategy,
        portfolio_handler, execution_handler,
        position_sizer, risk_manager,
        statistics, initial_equity
    )
    results = backtest.simulate_trading(testing=testing)
    statistics.save(filename)
    return results


@click.command()
@click.option('--config', default=settings.DEFAULT_CONFIG_FILENAME, help='Config filename')
@click.option('--testing/--no-testing', default=False, help='Enable testing mode')
@click.option('--tickers', default='SP500TR', help='Tickers (use comma)')
@click.option('--filename', default='', help='Pickle (.pkl) statistics filename')
def main(config, testing, tickers, filename):
    tickers = tickers.split(",")
    config = settings.from_file(config, testing)
    run(config, testing, tickers, filename)


if __name__ == "__main__":
    main()</code>
</pre>
        
        
        <script async data-uid="6296c27f4b" src="https://weathered-brook-5281.ck.page/6296c27f4b/index.js"></script>
      </section>
    </div>
    <div class="col-md-4 book-card order-md-1">
      
<div class="sidebar-advert-container">
  <a href="/qsalpha/?ref=art">
    <img class="card-img-top" src="/static/images/qsalpha-sidebar-advert-small.png" alt="QSAlpha">
  </a>
  <div class="card mb-4 box-shadow">
    <div class="card-body text-center">
      <h3 class="mb-3"><a class="link-fade" href="/qsalpha/?ref=art">QSAlpha</a></h3>
      <p class="card-text medium-text mb-3">Join the QSAlpha research platform that helps fill your strategy research pipeline, diversifies your portfolio and improves your risk-adjusted returns for increased profitability.</p>
      <div class="d-flex justify-content-center align-items-center">
        <div class="btn-group">
          <a class="btn btn-padded btn-outline-primary btn-lg-cta" href="/qsalpha/?ref=art">Find Out More</a>
        </div>
      </div>
    </div>
  </div>

  <a href="/quantcademy/?ref=art">
    <img class="card-img-top" src="/static/images/quantcademy-sidebar-advert-small.png" alt="Quantcademy">
  </a>
  <div class="card mb-4 box-shadow">
    <div class="card-body text-center">
      <h3 class="mb-3"><a class="link-fade" href="/quantcademy/?ref=art">The Quantcademy</a></h3>
      <p class="card-text medium-text mb-3">Join the Quantcademy membership portal that caters to the rapidly-growing retail quant trader community and learn how to increase your strategy profitability.</p>
      <div class="d-flex justify-content-center align-items-center">
        <div class="btn-group">
          <a class="btn btn-padded btn-outline-primary btn-lg-cta" href="/quantcademy/?ref=art">Find Out More</a>
        </div>
      </div>
    </div>
  </div>

  <a href="/successful-algorithmic-trading-ebook/">
    <img class="card-img-top" src="/static/images/sat-sidebar-advert-small.png" alt="Successful Algorithmic Trading">
  </a>
  <div class="card mb-4 box-shadow">
    <div class="card-body text-center">
      <h3 class="mb-3"><a class="link-fade" href="/successful-algorithmic-trading-ebook/">Successful Algorithmic Trading</a></h3>
      <p class="card-text medium-text mb-3">How to find new trading strategy ideas and objectively assess them for your portfolio using a Python-based backtesting engine.</p>
      <div class="d-flex justify-content-center align-items-center">
        <div class="btn-group">
          <a class="btn btn-padded btn-outline-primary btn-lg-cta" href="/successful-algorithmic-trading-ebook/">Find Out More</a>
        </div>
      </div>
    </div>
  </div>

  <a href="/advanced-algorithmic-trading-ebook/">
    <img class="card-img-top" src="/static/images/aat-sidebar-advert-small.png" alt="Advanced Algorithmic Trading">
  </a>
  <div class="card mb-4 box-shadow">
    <div class="card-body text-center">
      <h3 class="mb-3"><a class="link-fade" href="/advanced-algorithmic-trading-ebook/">Advanced Algorithmic Trading</a></h3>
      <p class="card-text medium-text mb-3">How to implement advanced trading strategies using time series analysis, machine learning and Bayesian statistics with R and Python.</p>
      <div class="d-flex justify-content-center align-items-center">
        <div class="btn-group">
          <a class="btn btn-padded btn-outline-primary btn-lg-cta" href="/advanced-algorithmic-trading-ebook/">Find Out More</a>
        </div>
      </div>
    </div>
  </div>
</div>
    </div>
  </div>
</section>

    

<footer>
  <div class="container container-full">
    <section class="mt-1.5 mb-1">
      <div class="row">
        <div class="col-12 col-sm-12 col-md-6 col-xl-3 mb-1.5">
          <ul class="footer-list">
            <li class="footer-list-title">QuantStart</li>
            <li class="footer-list-link"><a class="link-fade" href="/about/">About</a></li>
            <li class="footer-list-link"><a class="link-fade" href="/articles/">Articles</a></li>
            <li class="footer-list-link"><a class="link-fade" href="/sitemap/">Sitemap</a></li>
          </ul>
        </div>

        <div class="col-12 col-sm-12 col-md-6 col-xl-3 mb-1.5">
          <ul class="footer-list">
            <li class="footer-list-title">Products</li>
            
            <li class="footer-list-link"><a class="link-fade" href="/qsalpha/">QSAlpha</a></li>
            
            
            <li class="footer-list-link"><a class="link-fade" href="/quantcademy/">Quantcademy</a></li>
            
            <li class="footer-list-link"><a class="link-fade" href="/qstrader/">QSTrader</a></li>
            <li class="footer-list-link"><a class="link-fade" href="/successful-algorithmic-trading-ebook/">Successful Algorithmic Trading</a></li>
            <li class="footer-list-link"><a class="link-fade" href="/advanced-algorithmic-trading-ebook/">Advanced Algorithmic Trading</a></li>
            <li class="footer-list-link"><a class="link-fade" href="/cpp-for-quantitative-finance-ebook/">C++ For Quantitative Finance</a></li>
          </ul>
        </div>

        <div class="col-12 col-sm-12 col-md-6 col-xl-3 mb-1.5">
          <ul class="footer-list">
            <li class="footer-list-title">Legal</li>
            <li class="footer-list-link"><a class="link-fade" href="/privacy-policy/">Privacy Policy</a></li>
            <li class="footer-list-link"><a class="link-fade" href="/terms-and-conditions/">Terms &amp; Conditions</a></li>
          </ul>
        </div>

        <div class="col-12 col-sm-12 col-md-6 col-xl-3 mb-1.5">
          <ul class="footer-list">
            <li class="footer-list-title">Social</li>
            <li class="footer-list-link"><a class="link-fade" href="https://twitter.com/quantstart">Twitter</a></li>
            <li class="footer-list-link"><a class="link-fade" href="https://www.youtube.com/channel/UCmVnnZ6Y2TrJtY1eQJN6kWA">YouTube</a></li>
          </ul>
        </div>
      </div>
    </section>

    <div class="row mb-1.5 mt-5">
      <div class="col-12 col-md-9 col-lg-8 col-xl-6">
        <div class="footer-copyright">
          <p>Â©2012-2023 QuarkGluon Ltd. All rights reserved.</p>
        </div>
      </div>
    </div>
  </div>
</footer>

    
<script src="/static/js/jquery-3.2.1.min.js"></script>
<script src="/static/js/prism.js.min"></script>
<script src="/static/js/bootstrap.min.js"></script>
<script src="/static/js/nav.js"></script>

<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-5383959-5']);
  _gaq.push(['_trackPageview']);

  (function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>


    
<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
  }
};
</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script src="/static/js/highcharts/highcharts.js"></script>
<script type="text/javascript">
  num_colours = 10;
</script>
<script src="/static/js/statistics.js"></script>


  </body>
</html>
